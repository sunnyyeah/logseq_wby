- go 是强类型语言
	- **强类型语言**是一种强制类型定义的语言，即一旦某一个变量被定义类型，如果不经强制转换，那么它永远就是该数据类型。
	- **弱类型语言**是一种弱类型定义的语言，某一个变量被定义类型，该变量可以根据环境变化自动进行转换，不需要经过现行强制转换。
- ## 变量表示形式
	- { 必须放在最右边，不能够换行显示
	- 变量声明
	  collapsed:: true
		- ```
		  // 指定类型
		  var param1, param2 type  
		  param1, param2 = v1, v2
		  
		  // 自动类型判断
		  var param1, param2 = v1, v2	
		  
		  // 初始化声明
		  param1, param2 := v1, v2 // 这种写法只能用在函数体内，不可以用在全局变量中	
		  
		  // 因式分解写法，常用于声明全局变量
		  var (
		  	vname1 v_type1
		      vname2 v_type2
		  )
		  ```
		- 使用 **:=** 进行声明
			- 正确用法：
				- ```
				  initVal := 1
				  
				  // 上面的语句等价于
				  var initVal int
				  initVal = 1
				  ```
			- 错误用法：
				- ```
				  var initVal int
				  initVal := 1	// 这个语句中包含了声明的操作，上面的语句会导致重复声明的问题
				  ```
	- 引入包
		- ```
		  import "packageName"  // 单个包
		  import (
		  	"packageName1"
		      "packageName2"
		  )
		  ```
-
- ## 变量类型
	- 值类型
		- 所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值
		- 当使用等号 = 将一个变量的值赋值给另一个变量时，如：j = i，实际上是在内存中将 i 的值进行了拷贝（深拷贝）
		- 值类型变量的值存储在堆中
	- 引用类型
		- 引用类型的变量存储的是值的内存地，或内存地址中第一个字所在的位置
		- 这个内存地址称之为指针
		- 当使用赋值语句 r2 = r1 时，只有引用（地址）被复制（前拷贝）
-
- ## 类型断言
  collapsed:: true
	- 使用 value.(type) 的方式进行类型断言
		- ```go
		  package main
		  
		  import "fmt"
		  
		  func main() {
		  	// 只要类型为 interface{} 的时候才能使用 value.(type) 的方式进行断言（在我目前的认识里是这样的）
		  	var a interface{} = 10
		  	var b interface{} = "abc"
		  
		  	t1, ok := a.(int)
		  	fmt.Println("a.(int)", t1, ok)		// 10 true
		  
		  	t2, ok2 := a.(string)
		  	fmt.Println("a.(string)", t2, ok2)	//    false
		  
		  	// 如果这里不加 ok3，那么会在终端报错：
		      // panic: interface conversion: interface {} is string, not int
		  	t3, ok3 := b.(int)
		  	fmt.Println("b.(int)", t3, ok3)		//    false
		  
		  	// 也可以直接返回一个参数，不加 OK
		      // 但是只有当这个断言是成功的时候才能这么搞
		  	t4 := b.(string)
		  	fmt.Println("b.(string)", t4)		// abc 
		  }
		  
		  ```
-
- ## 变量在栈上还是堆上？
	- 一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。
	- **编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用 var 还是 new 声明变量的方式决定的。**
	- 例子：
		- ```go
		  var global *int
		  
		  func f() {
		      var x int  		// 这个变量被分配在堆上，因为它在函数退出后依然可以通过包一级的global变量找到
		      x = 1
		      global = &x
		  }
		  
		  func g() {
		      y := new(int)	// *y并没有从函数g中逃逸，编译器可以选择在栈上分配*y的存储空间
		      *y = 1
		  }
		  ```
-
- ## 常量
  collapsed:: true
	- 定义
		- ```go
		  const param [type] = value
		  // [type] 表示可选，这个跟变量声明一样，可以通过自动类型推断来的值当前参数类型
		  ```
	- iota
		- iota，特殊常量，可以认为是一个可以被编译器修改的常量。
		- iota 在 const 关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。
		- 实例
			- ```go
			  package main
			  
			  import "fmt"
			  
			  func main() {
			      const (
			              a = iota   //0
			              b          //1
			              c          //2
			              d = "ha"   //独立值，iota += 1
			              e          //"ha"   iota += 1
			              f = 100    //iota +=1
			              g          //100  iota +=1
			              h = iota   //7,恢复计数
			              i          //8
			      )
			      fmt.Println(a,b,c,d,e,f,g,h,i)
			  }
			  
			  // output: 0 1 2 ha ha 100 100 7 8
			  ```
-
-