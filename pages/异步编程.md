- 同步：每条指令会严格按照他们在内存中的顺序来执行，简单来说后面的指令必须等待前面的指令执行完成之后才能执行。
- 异步：指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。（这个看起来有点像是触发了一个中断，中断了当前的任务，然后执行其他任务，当其他任务执行完之后再回来继续执行当前任务）
-
- Javascript 是单线程的，那么要怎样执行异步代码呢？ [运行机制](https://segmentfault.com/a/1190000015806981)
	- 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。
	- js 引擎执行异步代码而不用等待，是因有为有 消息队列和事件循环。
		- 消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。
		- 事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。
		- 实际上，主线程只会做一件事情，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环。
	- 如何理解消息？
		- 简单来说，消息就是注册异步任务时添加的回调函数。
-
- 任务队列
	- macroTask（task）：可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）
		- 主代码块, setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI rendering（可以看到，事件队列中的每一个事件都是一个macrotask），Promise 的构造函数
		- 这里有一点挺奇怪的，将 主代码块 划分为 macro
	- microTask（job）：可以理解是在当前 task 执行结束后立即执行的任务
		- process.nextTick, Promise, Object.observe, MutationObserver
	- 浏览器为了能够使得 JS 内部 task 与 DOM 任务能够有序的执行，会在一个 task 执行结束后，在下一个 task 执行开始前，对页面进行重新渲染
	- 所以执行顺序其实是：macro（表示的是 代码块，并不是异步任务中的 macro） - micro - 渲染
		- 实际上 micro 是在 macro 之前执行的
	- 例子🌰
		- ```JavaScript
		  // 同步任务
		  console.log('main1');		
		  
		  // 异步任务
		  process.nextTick(function() {	// micro  task
		      console.log('process.nextTick1');
		  });
		  
		  // 异步任务，会进入任务队列
		  setTimeout(function() {	
		      console.log('setTimeout');	// macro task
		      process.nextTick(function() {
		          console.log('process.nextTick2');	// micro task
		      });
		  }, 0);
		  
		  // new Promise 是一个同步任务，会立即执行
		  new Promise(function(resolve, reject) { 
		      console.log('promise'); 	
		      resolve();
		  }).then(function() {
		    // Promise 的 then 是一个异步任务
		      console.log('promise then');	// micro task
		  });
		  
		  // 同步任务
		  console.log('main2');
		  
		  // output
		  // main1
		  // promise
		  // main2
		  // process.nextTick1
		  // promise then
		  // setTimeout
		  // process.nextTick2
		  ```
		- 这里为什么 promise then 会在 setTimeout 之前执行呢？
			- 因为 micro task 优先于 macro task 执行
-
-
-
	-
	- 那么我们可以理解一下 任务的执行顺序 实际上就是：
		- 同步任务
		- 异步 micro task
		- 异步 macro task
-
- 以前的异步操作
	- 使用 **setTimeout**，该函数的第一个参数就一个回调函数，第二个参数是将回调函数推到消息队列的时机。setTimeout 所做的操作就是在运行时将回调函数推到自己的消息队列上去等待执行。
	- 失败处理：使用 try-catch 进行处理
	- 嵌套异步回调（回调地狱）
-
- Promise
	- ECMA Script6 新增的引用类型。
	- Promise 构造函数是同步执行（也就是说 new Promise 其实是一个 macroTask），then/catch 是异步执行，并且 then/catch 的内容会放到 微任务 中。
	- async/await 中，await 前面的是同步，await 后面的是异步，
-
-
- 我感觉好奇怪啊，异步函数表示的就是这个函数并不是顺序执行的对吧。
	- 假如我所有函数都是同步的，假如我有 func1、func2、func3，三个函数，那么执行顺序就是 123；假如func1 是一个异步函数，那么这个时候执行顺序就可能是 231 了。也就说 func1 并不会阻塞 23。这么看好像没啥毛病
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-