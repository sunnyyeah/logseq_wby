- Go 语言支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。
- goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。
- Go 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine 共享同一个地址空间。
- main 函数本身也运行在一个 goroutine 中，而go function则表示创建一个新的 goroutine，并在这个新的 goroutine 中执行这个函数。
-
- 语法格式
	- ```
	  go 函数名( 参数列表 )
	  ```
-
- 实例
	- ```
	  package main
	  
	  import (
	    "fmt"
	    "time"
	  )
	  
	  func say(s string) {
	    for i := 0; i < 5; i++ {
	      time.Sleep(100 * time.Millisecond)
	      fmt.Println(s)
	    }
	  }
	  
	  func main() {
	    // 开启一个新线程运行 world
	    go say("world")
	    say("hello")
	  }
	  
	  // output 
	  // world
	  // hello
	  // hello
	  // world
	  // world
	  // hello
	  // hello
	  // world
	  // world
	  // hello
	  ```
-
- ## 通道（channel）
	- channel 是有锁的
	- 通道是用来传递数据的一个数据结构。
	- 通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。
	- 操作符 <- 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。
	- 传送方式
		- ```
		  ch <- v    // 把 v 发送到通道 ch
		  v := <-ch  // 从 ch 接收数据
		             // 并把值赋给 v
		  ```
	- 声明通道：**使用 chan 关键字**，通道在使用前必须先创建
		- ```
		  ch := make(chan int)
		  ```
	- 【⚠️注意】默认情况下，通道是不带缓冲区的。发送端发送数据，同时必须有接收端相应的接收数据。
	- 高并发、高性能编程不适合使用 channel
	-
	- 实例：两个 goroutine 来计算数字之和
		- ```
		  package main
		  
		  import "fmt"
		  
		  func sum(s []int, c chan int) {
		          sum := 0
		          for _, v := range s {
		                  sum += v
		          }
		          c <- sum // 把 sum 发送到通道 c
		  }
		  
		  func main() {
		          s := []int{7, 2, 8, -9, 4, 0}
		  
		          c := make(chan int)
		          go sum(s[:len(s)/2], c)
		          go sum(s[len(s)/2:], c)
		          x, y := <-c, <-c // 从通道 c 中接收
		  
		          fmt.Println(x, y, x+y)
		  }
		  ```
-
- ## 通道缓冲区
	- 可以通过 make 的第二个参数设置缓冲区大小：
		- ```
		  ch := make(chan int, 100)	// 如果没有第二参数，那么生成的 channel 是不带缓冲区的
		  ```
	- 带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。
		- 带缓冲区的通道可以解决消费者和生产者速度不均衡的问题。比如消费者的消费速度 < 生产者的生产速度，那么也不会 block 生产者继续生产。
	- 不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。(无缓冲通道又被称为同步通道)
	- 【注意】如果通道**不带缓冲**，发送方会阻塞直到接收方从通道中接收了值。如果通道**带缓冲**，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果**缓冲区已满**，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。
	- 除了上面的区别以外，有缓冲区的 channel 会发生两次 copy（send goroutine > buffer，buffer > receive goroutine），无缓冲区的 channel 只会发生一次 copy（send goroutine > receive goroutine）
-
- Go 遍历通道与关闭通道
	- 当接收不到数据的时候 ok 为 false
		- ```go
		  v, ok := <-ch
		  ```
	- 可以通过 close() 来关闭通道
		- ```go
		  package main
		  
		  import (
		          "fmt"
		  )
		  
		  func fibonacci(n int, c chan int) {
		          x, y := 0, 1
		          for i := 0; i < n; i++ {
		                  c <- x
		                  x, y = y, x+y
		          }
		          close(c)
		  }
		  
		  func main() {
		          c := make(chan int, 10)
		          go fibonacci(cap(c), c)
		          // range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个
		          // 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据
		          // 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不
		          // 会结束，从而在接收第 11 个数据的时候就阻塞了。
		          for i := range c {
		                  fmt.Println(i)
		          }
		  }
		  ```
-
-
- ## 📝 解决并发问题
	- mutex（性能不太好）
	- 读写锁
	- atomic.value：可以原子的写入和读取数据
	- unsafe.pointer